const Anthropic = require("@anthropic-ai/sdk");
const { corsHeaders } = require("../shared/helpers");

module.exports = async function (context, req) {
  if (req.method === "OPTIONS") {
    context.res = { status: 204, headers: corsHeaders(req) };
    return;
  }

  try {
    const { tasks, context: ctx } = req.body;

    if (!tasks || !Array.isArray(tasks)) {
      context.res = {
        status: 400,
        headers: corsHeaders(req),
        body: JSON.stringify({ ok: false, error: "tasks array required" })
      };
      return;
    }

    const apiKey = process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      context.res = {
        status: 500,
        headers: corsHeaders(req),
        body: JSON.stringify({ ok: false, error: "ANTHROPIC_API_KEY not configured" })
      };
      return;
    }

    // Prepare task summary for AI
    const taskSummary = tasks.map(t => {
      let deps = "none";
      if (t.dependencies) {
        if (Array.isArray(t.dependencies)) {
          deps = t.dependencies.length > 0 ? t.dependencies.join(", ") : "none";
        } else if (typeof t.dependencies === 'string') {
          deps = t.dependencies || "none";
        }
      }

      return {
        id: t.id,
        status: t.status,
        description: t.description || "",
        phase: t.phase || "",
        workstream: t.workstream || "",
        executor: t.executor || "",
        blocker: t.blocker || "",
        startDate: t.startDate || "",
        endDate: t.endDate || "",
        dependencies: deps
      };
    });

    // Build context description
    let contextDesc = "";
    if (ctx?.focusDate) {
      contextDesc += `Focus Date: ${ctx.focusDate}\n`;
    }
    if (ctx?.focusMode) {
      contextDesc += `Focus Mode: ${ctx.focusMode}\n`;
    }
    if (ctx?.phaseFilter && ctx.phaseFilter !== "all") {
      contextDesc += `Phase Filter: ${ctx.phaseFilter}\n`;
    }
    if (ctx?.generatedBy) {
      contextDesc += `Generated by: ${ctx.generatedBy}\n`;
    }

    // Call Anthropic API
    const anthropic = new Anthropic({ apiKey });

    const prompt = `You are a project manager creating a concise standup briefing for an M3 ERP cutover migration.

${contextDesc ? `Context:\n${contextDesc}\n` : ""}
Tasks (${tasks.length} total):
${JSON.stringify(taskSummary, null, 2)}

Generate a standup briefing in the following EXACT format:

**Header:** One line with format: \`{focusDate} | {taskCount} tasks in view | Focus: {focusMode}\`

Then organize tasks into these sections (use ## markdown headers):

## BLOCKERS
- List any tasks with status "3-Blocked"
- Format each as: \`{ID}: {description} | {executor} | {phase} | Due {endDate} | BLOCKER: {blocker}\`
- If none, write: "None"

## IN PROGRESS
- List any tasks with status "2-WIP"
- Format each as: \`{ID}: {description} | {executor} | {phase} | Due {endDate}\`
- If none, write: "None"

## DUE TODAY
- List any tasks with status "1-Planned" where endDate â‰¤ focusDate
- Format each as: \`{ID}: {description} | {executor} | {phase} | Due {endDate}\`
- If none, write: "None"

## WATCH ITEMS
- List any tasks that have pending dependencies (dependencies field not empty and not "none")
- Format each as: \`{ID}: {description} | {executor} | {phase} | DEPENDS ON: {dependencies}\`
- If none, write: "None"

**Closing:** One sentence summarizing overall readiness for the day.

IMPORTANT RULES:
- Keep each bullet to ONE LINE
- Use task IDs prominently
- Be direct and action-oriented
- NO filler language
- If a field is empty, use "Unassigned" for executor, "N/A" for phase/date`;

    const message = await anthropic.messages.create({
      model: "claude-sonnet-4-6",
      max_tokens: 1024,
      messages: [{
        role: "user",
        content: prompt
      }]
    });

    const summary = message.content[0].text;

    context.res = {
      status: 200,
      headers: { ...corsHeaders(req), "Content-Type": "application/json" },
      body: JSON.stringify({ ok: true, summary })
    };

  } catch (e) {
    context.log.error("Summary generation error:", e);
    context.res = {
      status: 500,
      headers: corsHeaders(req),
      body: JSON.stringify({ ok: false, error: e.message || "Failed to generate summary" })
    };
  }
};
